// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repository

import (
	"context"
)

const getBook = `-- name: GetBook :one
SELECT id, title, slug, description, duration, "coverImage", rating, "totalRating", language, "createdAt", "updatedAt", published FROM "Book"
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBook(ctx context.Context, id string) (Book, error) {
	row := q.db.QueryRow(ctx, getBook, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Duration,
		&i.CoverImage,
		&i.Rating,
		&i.TotalRating,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
	)
	return i, err
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, slug, description, duration, "coverImage", rating, "totalRating", language, "createdAt", "updatedAt", published FROM "Book"
ORDER BY "createdAt" DESC
`

func (q *Queries) ListBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Duration,
			&i.CoverImage,
			&i.Rating,
			&i.TotalRating,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesByBookID = `-- name: ListCategoriesByBookID :many
SELECT c.id, c.name, c.slug, c.description, c."imageUrl", c.color, c."createdAt", c."updatedAt", c."isActive" FROM "Category" c
JOIN "_BookToCategory" btc ON btc."B" = c.id
WHERE btc."A" = $1
`

func (q *Queries) ListCategoriesByBookID(ctx context.Context, a string) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategoriesByBookID, a)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ImageUrl,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSimilarBooks = `-- name: ListSimilarBooks :many
SELECT DISTINCT b.id, b.title, b.slug, b.description, b.duration, b."coverImage", b.rating, b."totalRating", b.language, b."createdAt", b."updatedAt", b.published FROM "Book" b
JOIN "_BookToCategory" btc ON btc."A" = b.id
JOIN "Category" c ON btc."B" = c.id
WHERE c.id = $1
LIMIT 12
`

func (q *Queries) ListSimilarBooks(ctx context.Context, id string) ([]Book, error) {
	rows, err := q.db.Query(ctx, listSimilarBooks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Duration,
			&i.CoverImage,
			&i.Rating,
			&i.TotalRating,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrendingBooks = `-- name: ListTrendingBooks :many
SELECT id, title, slug, description, duration, "coverImage", rating, "totalRating", language, "createdAt", "updatedAt", published FROM "Book"
ORDER BY "createdAt" DESC
LIMIT 10
`

func (q *Queries) ListTrendingBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, listTrendingBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Duration,
			&i.CoverImage,
			&i.Rating,
			&i.TotalRating,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
